# This file contains the core logic for generating gap-filling exercises
# import google.generativeai as genai
# from dotenv import load_dotenv
# load_dotenv()
# api_key = os.getenv("GEMINI_API_KEY")
# genai.configure(api_key=api_key)

import random
from typing import List, Tuple

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import GapFillingTable, Translation

# ToDo(Qin): For exercise generating, "sentence", "correct_word", and "translation" should be read from
#  translation_model. "options" will be mocked here for now.
# ToDo(Qin): In the future, the "options" should be generated by Open Learner Model.
# ToDo(Qin): We don't use Gemini for generating exercises for now.

MOCK_OPTIONS = ["option1", "option2", "option3"]


def create_gap_filling_exercise(translation: Translation) -> Tuple[str, List[str]]:
    """
    Generate a gap-filling exercise based on the given translation.
    """
    gapped_sentence = translation.sentence.replace(
        translation.word, f"__({translation.translation})"
    )
    options = MOCK_OPTIONS + [translation.clean_word]
    random.shuffle(options)
    return gapped_sentence, options


async def generate_gap_filling_exercises(session: AsyncSession):
    """
    Fetch translations and generate gap-filling exercises.
    Save these exercises to the database.
    """
    stmt = select(Translation)
    translations = (await session.execute(stmt)).scalars().all()

    exercises = []
    for translation in translations:
        gapped_sentence, options = create_gap_filling_exercise(translation)
        exercise = GapFillingTable(
            id_in_translation_model=translation.id,
            gapped_sentence=gapped_sentence,
            options=options,
            correct_frequency=0,
        )
        exercises.append(exercise)

    session.add_all(exercises)
    await session.commit()
    return exercises


async def fetch_gap_filling_exercises(session: AsyncSession):
    """
    Fetch all existing gap-filling exercises from the database.
    """
    stmt = select(GapFillingTable).order_by(GapFillingTable.id)
    results = await session.execute(stmt)
    return results.scalars().all()


async def update_exercise_correctness(
    session: AsyncSession, exercise_id: int, is_correct: bool
):
    """
    Update the correctness frequency of a specific gap-filling exercise.
    """
    stmt = select(GapFillingTable).where(GapFillingTable.id == exercise_id)
    result = await session.execute(stmt)
    exercise = result.scalar_one_or_none()

    if exercise is None:
        return None

    if is_correct:
        exercise.correct_frequency += 1
        await session.commit()

    return exercise


# def generate_prompt(self, row):
#     return f"""
#     Task: Create a multiple-choice gap-filling exercise based on the following context.
#
#     Context:
#     - Original Sentence: {row.sentence}
#     - Word to Replace: {row.clean_word}
#     - Translation: {row.translation}
#
#     Instructions:
#     1. Create a gap in the original sentence by replacing '{row.clean_word}' with '____'
#     2. Generate 3 plausible distractors that:
#        - Are the same part of speech as '{row.clean_word}'
#        - Make sense in the context of the sentence
#        - Are not the correct word
#     3. Randomize the order of options
#     4. Ensure the correct answer is included
#
#     Output Format:
#     - Gapped Sentence
#     - Translation Hint
#     - 4 Options (A, B, C, D) in JSON format
#     """
#
# def call_gemini_api(self, prompt):
#     # model = genai.GenerativeModel("gemini-1.5-flash")
#     # response = model.generate_content(prompt)
#     # translated_text = response.text.strip()
#     model = genai.GenerativeModel('gemini-pro')
#     response = model.generate_content(prompt)
#     return response.text
#
